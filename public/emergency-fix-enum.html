<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EMERGENCY: Fix Database Enum</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    .critical { background: #fee; border: 2px solid #f00; padding: 15px; margin: 10px 0; }
    button { padding: 10px 20px; font-size: 16px; margin: 10px 5px; }
    .success { background: #efe; border: 2px solid #0a0; padding: 10px; }
    .error { background: #fee; border: 2px solid #f00; padding: 10px; }
    #output { margin-top: 20px; white-space: pre-wrap; font-family: monospace; background: #f5f5f5; padding: 10px; max-height: 400px; overflow-y: auto; }
  </style>
</head>
<body>
  <div class="critical">
    <h1>üö® CRITICAL DATABASE FIX REQUIRED</h1>
    <p><strong>Issue:</strong> The 'partially-fulfilled' enum value is missing from your database!</p>
    <p><strong>Impact:</strong> This affects ALL customers, not just demo account</p>
    <p><strong>Solution:</strong> Add the missing enum value to database</p>
  </div>
  
  <button onclick="checkEnum()" style="background: #ff9;">1. Check Current Enum</button>
  <button onclick="fixEnum()" style="background: #f99;">2. FIX DATABASE ENUM</button>
  <button onclick="testAfterFix()" style="background: #9f9;">3. Test After Fix</button>
  
  <div id="output"></div>

  <script type="module">
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
    
    const supabaseUrl = 'https://niqtlyirrjjsowlihfey.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5pcXRseWlycmpqc293bGloZmV5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzM2Nzc5MDQsImV4cCI6MjA0OTI1MzkwNH0.ux_tWYFCOepfvHAE9ZQh5pNrqMfaeBgFq8vZcjwbD0E';
    const supabase = createClient(supabaseUrl, supabaseKey);
    
    function log(message, type = 'info') {
      const output = document.getElementById('output');
      const timestamp = new Date().toLocaleTimeString();
      output.textContent += `[${timestamp}] ${message}\n`;
      output.scrollTop = output.scrollHeight;
      console.log(message);
      
      if (type === 'success') {
        const div = document.createElement('div');
        div.className = 'success';
        div.textContent = message;
        document.body.appendChild(div);
      } else if (type === 'error') {
        const div = document.createElement('div');
        div.className = 'error';
        div.textContent = message;
        document.body.appendChild(div);
      }
    }
    
    window.checkEnum = async function() {
      try {
        log('üîç Checking current requirement_status enum values...');
        
        // This is a direct SQL query to check enum values
        const query = `
          SELECT enumlabel as value, enumsortorder as sort_order 
          FROM pg_enum 
          WHERE enumtypid = 'requirement_status'::regtype 
          ORDER BY enumsortorder;
        `;
        
        // Try different ways to execute this
        try {
          const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {
            method: 'POST',
            headers: {
              'apikey': supabaseKey,
              'Authorization': `Bearer ${supabaseKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ query })
          });
          
          if (response.ok) {
            const data = await response.json();
            log('Current enum values: ' + JSON.stringify(data));
          } else {
            throw new Error('RPC call failed');
          }
        } catch (rpcError) {
          log('RPC method failed, trying alternative...');
          
          // Alternative: Check what values actually exist in the table
          const { data: statusData, error } = await supabase
            .from('organization_requirements')
            .select('status')
            .limit(1000);
            
          if (error) throw error;
          
          const uniqueStatuses = [...new Set(statusData.map(r => r.status))].sort();
          log(`Values found in actual data: ${uniqueStatuses.join(', ')}`);
          
          if (!uniqueStatuses.includes('partially-fulfilled')) {
            log('‚ùå CONFIRMED: partially-fulfilled is MISSING from database!', 'error');
          } else {
            log('‚úÖ partially-fulfilled found in data');
          }
        }
        
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'error');
      }
    };
    
    window.fixEnum = async function() {
      try {
        log('üîß ATTEMPTING TO FIX DATABASE ENUM...');
        log('‚ö†Ô∏è This will add partially-fulfilled to requirement_status enum');
        
        // Multiple approaches to fix the enum
        const fixQueries = [
          "ALTER TYPE requirement_status ADD VALUE IF NOT EXISTS 'partially-fulfilled';",
          "ALTER TYPE requirement_status ADD VALUE 'partially-fulfilled' AFTER 'fulfilled';",
          "ALTER TYPE requirement_status ADD VALUE 'partially-fulfilled' BEFORE 'not-fulfilled';"
        ];
        
        for (const query of fixQueries) {
          try {
            log(`Trying: ${query}`);
            
            const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {
              method: 'POST',
              headers: {
                'apikey': supabaseKey,
                'Authorization': `Bearer ${supabaseKey}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ query })
            });
            
            if (response.ok) {
              log('‚úÖ DATABASE ENUM FIXED!', 'success');
              break;
            } else {
              const errorText = await response.text();
              log(`‚ùå Query failed: ${errorText}`);
            }
          } catch (queryError) {
            log(`‚ùå Query error: ${queryError.message}`);
          }
        }
        
      } catch (error) {
        log(`‚ùå Critical error: ${error.message}`, 'error');
      }
    };
    
    window.testAfterFix = async function() {
      try {
        log('üß™ Testing partially-fulfilled after fix...');
        
        // Get a test requirement
        const { data: testReq, error: fetchError } = await supabase
          .from('organization_requirements')
          .select('id, status')
          .limit(1)
          .single();
          
        if (fetchError) throw fetchError;
        
        const originalStatus = testReq.status;
        log(`Testing with requirement ${testReq.id} (current: ${originalStatus})`);
        
        // Try to update to partially-fulfilled
        const { error: updateError } = await supabase
          .from('organization_requirements')
          .update({ status: 'partially-fulfilled' })
          .eq('id', testReq.id);
          
        if (updateError) {
          log(`‚ùå Still failing: ${updateError.message}`, 'error');
          return;
        }
        
        log('‚úÖ partially-fulfilled update SUCCESS!', 'success');
        
        // Revert back
        await supabase
          .from('organization_requirements')
          .update({ status: originalStatus })
          .eq('id', testReq.id);
          
        log('‚úÖ Test complete - database is now fixed!', 'success');
        
      } catch (error) {
        log(`‚ùå Test error: ${error.message}`, 'error');
      }
    };
  </script>
</body>
</html>